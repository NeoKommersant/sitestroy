"use client";  import { useMemo, useRef, useState, type ChangeEvent } from "react"; import * as XLSX from "xlsx"; import type { Category, Item } from "@/types/catalog";  type EditableCategory = Category;  type ImportSummary = {   categories: number;   subcategories: number;   items: number; };  type ImportPreview = {   filename: string;   data: EditableCategory[];   summary: ImportSummary;   warnings: string[];   errors: string[]; };  type ImportState =   | { status: "idle" }   | { status: "loading" }   | { status: "ready"; preview: ImportPreview }   | { status: "error"; message: string };  type AdminClientPageProps = {   initialCatalog: Category[]; };  const CYRILLIC_MAP: Record<string, string> = {   а: "a",   б: "b",   в: "v",   г: "g",   д: "d",   е: "e",   ё: "e",   ж: "zh",   з: "z",   и: "i",   й: "y",   к: "k",   л: "l",   м: "m",   н: "n",   о: "o",   п: "p",   р: "r",   с: "s",   т: "t",   у: "u",   ф: "f",   х: "h",   ц: "c",   ч: "ch",   ш: "sh",   щ: "shh",   ъ: "",   ы: "y",   ь: "",   э: "e",   ю: "yu",   я: "ya", };  const slugify = (input: string) => {   const lower = input.trim().toLowerCase();   let transliterated = "";   for (const char of lower) {     transliterated += CYRILLIC_MAP[char] ?? char;   }   const normalized = transliterated     .replace(/[^a-z0-9\s_-]/g, "")     .replace(/\s+/g, "-")     .replace(/-+/g, "-")     .replace(/^-|-$/g, "");   return normalized || `item-${Date.now()}`; };  const generateSku = (value: string) => {   const base = slugify(value);   const normalized = base.replace(/[^a-z0-9-]/g, "");   return normalized ? normalized.toUpperCase().replace(/-/g, "_") : `SKU-${Date.now()}`; };  const cloneCatalog = (data: Category[]): EditableCategory[] =>   data.map((category) => ({     ...category,     sub: category.sub.map((sub) => ({       ...sub,       items: sub.items.map((item) => ({ ...item })),     })),   }));  const prepareEmptyCatalog = (catalog: EditableCategory[]): EditableCategory[] =>   catalog.map((category) => ({     ...category,     sub: category.sub.map((sub) => ({       ...sub,       items: [],     })),   }));  const ensureItemShape = (item: Item): Item => {   const title = item.title.trim();   const slug = item.slug?.trim() || slugify(title);   const sku = item.sku?.trim() || generateSku(title);   return {     ...item,     title,     slug,     sku,     desc: item.desc?.trim() ? item.desc.trim() : undefined,   }; };  const prepareCatalogForExport = (catalog: EditableCategory[]): EditableCategory[] =>   cloneCatalog(catalog).map((category) => ({     ...category,     sub: category.sub.map((sub) => ({       ...sub,       items: sub.items.map((item) => ensureItemShape(item)),     })),   }));  const normalizeCell = (value: unknown) => {   if (value === undefined || value === null) return "";   if (typeof value === "string") return value.trim();   if (typeof value === "number") return `${value}`;   return String(value).trim(); };  const REQUIRED_HEADERS = ["категория", "подкатегория", "наименование"] as const;  const normalizeHeader = (header: string) => header.trim().toLowerCase(); const parseExcelFile = async (   file: File,   baseCatalog: EditableCategory[], ): Promise<ImportPreview> => {   const buffer = await file.arrayBuffer();   const workbook = XLSX.read(buffer, { type: "array" });   const sheetName = workbook.SheetNames[0];   if (!sheetName) {     throw new Error("Файл не содержит листов.");   }   const sheet = workbook.Sheets[sheetName];   const rawRows = XLSX.utils.sheet_to_json<Record<string, unknown>>(sheet, { defval: "" });   if (rawRows.length === 0) {     throw new Error("Файл не содержит данных.");   }    const emptyCatalog = prepareEmptyCatalog(baseCatalog);   const categoryTitleMap = new Map(     baseCatalog.map((category) => [category.title.trim().toLowerCase(), category.slug]),   );   const subcategoryTitleMap = new Map<string, Map<string, string>>();   baseCatalog.forEach((category) => {     const subMap = new Map<string, string>();     category.sub.forEach((sub) => subMap.set(sub.title.trim().toLowerCase(), sub.slug));     subcategoryTitleMap.set(category.slug, subMap);   });    const catalogIndex = new Map<string, EditableCategory>();   emptyCatalog.forEach((category) => catalogIndex.set(category.slug, category));    const warnings = new Set<string>();   const errors: string[] = [];    rawRows.forEach((row, index) => {     const rowNumber = index + 2;     const normalizedRow = Object.entries(row).reduce<Record<string, unknown>>((acc, [key, value]) => {       acc[normalizeHeader(key)] = value;       return acc;     }, {});      for (const header of REQUIRED_HEADERS) {       if (!normalizedRow[header] || normalizeCell(normalizedRow[header]) === "") {         errors.push(`Строка ${rowNumber}: заполните столбец "${header}".`);       }     }     if (errors.length && errors[errors.length - 1].includes(`Строка ${rowNumber}`)) {       return;     }      const categoryTitle = normalizeCell(normalizedRow["категория"]);     const subcategoryTitle = normalizeCell(normalizedRow["подкатегория"]);     const itemTitle = normalizeCell(normalizedRow["наименование"]);     const itemDescription = normalizeCell(normalizedRow["описание"]);      const categorySlug = categoryTitleMap.get(categoryTitle.toLowerCase());     if (!categorySlug) {       errors.push(`Строка ${rowNumber}: категория "${categoryTitle}" не найдена в каталоге.`);       return;     }      const subMap = subcategoryTitleMap.get(categorySlug);     const subSlug = subMap?.get(subcategoryTitle.toLowerCase());     if (!subSlug) {       errors.push(         `Строка ${rowNumber}: подкатегория "${subcategoryTitle}" не найдена в категории "${categoryTitle}".`,       );       return;     }      const targetCategory = catalogIndex.get(categorySlug);     const targetSubcategory = targetCategory?.sub.find((sub) => sub.slug === subSlug);     if (!targetSubcategory) {       errors.push(         `Строка ${rowNumber}: не удалось определить подкатегорию "${subcategoryTitle}" в категории "${categoryTitle}".`,       );       return;     }      const slug = slugify(itemTitle);     const sku = generateSku(itemTitle);     if (targetSubcategory.items.some((item) => item.slug === slug)) {       warnings.add(         `Строка ${rowNumber}: позиция "${itemTitle}" заменит существующую в "${categoryTitle} / ${subcategoryTitle}".`,       );       targetSubcategory.items = targetSubcategory.items.map((item) =>         item.slug === slug ? { ...item, title: itemTitle, sku, desc: itemDescription } : item,       );     } else {       targetSubcategory.items.push({         slug,         title: itemTitle,         sku,         desc: itemDescription || undefined,       });     }   });    const summary: ImportSummary = {     categories: emptyCatalog.length,     subcategories: emptyCatalog.reduce((acc, category) => acc + category.sub.length, 0),     items: emptyCatalog.reduce(       (acc, category) =>         acc + category.sub.reduce((subAcc, subcategory) => subAcc + subcategory.items.length, 0),       0,     ),   };    return {     filename: file.name,     data: emptyCatalog,     summary,     warnings: Array.from(warnings),     errors,   }; };  const mergeCatalogs = (base: EditableCategory[], incoming: EditableCategory[]) => {   const next = cloneCatalog(base);   incoming.forEach((incomingCategory) => {     const category = next.find((cat) => cat.slug === incomingCategory.slug);     if (!category) return;     incomingCategory.sub.forEach((incomingSub) => {       const sub = category.sub.find((candidate) => candidate.slug === incomingSub.slug);       if (!sub) return;       incomingSub.items.forEach((incomingItem) => {         const formatted = ensureItemShape(incomingItem);         const existingIndex = sub.items.findIndex((item) => item.slug === formatted.slug);         if (existingIndex >= 0) {           sub.items[existingIndex] = formatted;         } else {           sub.items.unshift(formatted);         }       });     });   });   return next; }; export default function AdminClientPage({ initialCatalog }: AdminClientPageProps) {   const [catalog, setCatalog] = useState<EditableCategory[]>(() => cloneCatalog(initialCatalog));   const [selectedCategoryFilter, setSelectedCategoryFilter] = useState<string>("all");   const [selectedSubcategoryFilter, setSelectedSubcategoryFilter] = useState<string>("all");   const [clipboardStatus, setClipboardStatus] = useState<"idle" | "success" | "error">("idle");   const [importState, setImportState] = useState<ImportState>({ status: "idle" });   const [saveStatus, setSaveStatus] = useState<"idle" | "saving" | "success" | "error">("idle");   const fileInputRef = useRef<HTMLInputElement | null>(null);    const categoryOptions = useMemo(     () =>       catalog.map((category) => ({         value: category.slug,         label: category.title,       })),     [catalog],   );    const subcategoryOptions = useMemo(() => {     if (selectedCategoryFilter === "all") return [];     const category = catalog.find((cat) => cat.slug === selectedCategoryFilter);     return (       category?.sub.map((sub) => ({         value: sub.slug,         label: sub.title,       })) ?? []     );   }, [catalog, selectedCategoryFilter]);    const rows = useMemo(     () =>       catalog.flatMap((category) =>         category.sub.flatMap((subcategory) =>           subcategory.items.map((item) => ({             categorySlug: category.slug,             categoryTitle: category.title,             subcategorySlug: subcategory.slug,             subcategoryTitle: subcategory.title,             item,           })),         ),       ),     [catalog],   );    const filteredRows = useMemo(     () =>       rows.filter((row) => {         const matchCategory =           selectedCategoryFilter === "all" || row.categorySlug === selectedCategoryFilter;         const matchSub =           selectedSubcategoryFilter === "all" || row.subcategorySlug === selectedSubcategoryFilter;         return matchCategory && matchSub;       }),     [rows, selectedCategoryFilter, selectedSubcategoryFilter],   );    const jsonForExport = useMemo(     () => JSON.stringify(prepareCatalogForExport(catalog), null, 2),     [catalog],   );  const saveStatusMessage = saveStatus === "saving" ? "Сохраняем…" : saveStatus === "success" ? "Сохранено" : saveStatus === "error" ? "Ошибка" : "";  const saveStatusTone = saveStatus === "success" ? "text-emerald-600" : saveStatus === "error" ? "text-red-600" : "text-slate-500";    const updateItemInCatalog = (     categorySlug: string,     subcategorySlug: string,     itemSlug: string,     updater: (item: Item) => Item,   ) => {     setCatalog((prev) =>       prev.map((category) => {         if (category.slug !== categorySlug) return category;         return {           ...category,           sub: category.sub.map((subcategory) => {             if (subcategory.slug !== subcategorySlug) return subcategory;             return {               ...subcategory,               items: subcategory.items.map((item) =>                 item.slug === itemSlug ? updater(item) : item,               ),             };           }),         };       }),     );   };    const removeItemFromCatalog = (categorySlug: string, subcategorySlug: string, itemSlug: string) => {     setCatalog((prev) =>       prev.map((category) => {         if (category.slug !== categorySlug) return category;         return {           ...category,           sub: category.sub.map((subcategory) => {             if (subcategory.slug !== subcategorySlug) return subcategory;             return {               ...subcategory,               items: subcategory.items.filter((item) => item.slug !== itemSlug),             };           }),         };       }),     );   };    const moveItem = (     fromCategorySlug: string,     fromSubcategorySlug: string,     itemSlug: string,     toCategorySlug: string,     toSubcategorySlug: string,   ) => {     if (       fromCategorySlug === toCategorySlug &&       fromSubcategorySlug === toSubcategorySlug     ) {       return;     }      setCatalog((prev) => {       let movingItem: Item | undefined;        const withoutItem = prev.map((category) => {         if (category.slug !== fromCategorySlug) return category;         return {           ...category,           sub: category.sub.map((subcategory) => {             if (subcategory.slug !== fromSubcategorySlug) return subcategory;             const index = subcategory.items.findIndex((item) => item.slug === itemSlug);             if (index === -1) return subcategory;             const nextItems = [...subcategory.items];             [movingItem] = nextItems.splice(index, 1);             return { ...subcategory, items: nextItems };           }),         };       });        if (!movingItem) {         return prev;       }        return withoutItem.map((category) => {         if (category.slug !== toCategorySlug) return category;         return {           ...category,           sub: category.sub.map((subcategory) => {             if (subcategory.slug !== toSubcategorySlug) return subcategory;             return {               ...subcategory,               items: [movingItem as Item, ...subcategory.items],             };           }),         };       });     });   };    const handleAddItem = () => {     const targetCategorySlug =       selectedCategoryFilter !== "all"         ? selectedCategoryFilter         : categoryOptions[0]?.value;     if (!targetCategorySlug) return;      const category = catalog.find((cat) => cat.slug === targetCategorySlug);     if (!category || category.sub.length === 0) return;      const targetSubSlug =       selectedSubcategoryFilter !== "all" && selectedCategoryFilter !== "all"         ? selectedSubcategoryFilter         : category.sub[0]?.slug;     if (!targetSubSlug) return;      const newItem: Item = {       slug: `item-${Date.now()}`,       title: "",       desc: "",       sku: "",     };      setCatalog((prev) =>       prev.map((cat) => {         if (cat.slug !== targetCategorySlug) return cat;         return {           ...cat,           sub: cat.sub.map((subcategory) => {             if (subcategory.slug !== targetSubSlug) return subcategory;             return {               ...subcategory,               items: [newItem, ...subcategory.items],             };           }),         };       }),     );   };   const handleCopyJson = async () => {     try {       await navigator.clipboard.writeText(jsonForExport);       setClipboardStatus("success");       setTimeout(() => setClipboardStatus("idle"), 2600);     } catch (error) {       console.error(error);       setClipboardStatus("error");       setTimeout(() => setClipboardStatus("idle"), 2600);     }   };  const saveCatalogToRepo = async () => {     try {       setSaveStatus("saving");       const prepared = prepareCatalogForExport(catalog);       const response = await fetch("/api/update-catalog", {         method: "POST",         headers: { "Content-Type": "application/json" },         body: JSON.stringify({ catalog: prepared }),       });       if (!response.ok) {         console.error("Failed to save catalog", await response.text());         setSaveStatus("error");         return;       }       setSaveStatus("success");     } catch (error) {       console.error("Failed to save catalog", error);       setSaveStatus("error");     }   };    const handleImportFile = async (file: File) => {     setImportState({ status: "loading" });     try {       const preview = await parseExcelFile(file, catalog);       setImportState({ status: "ready", preview });     } catch (error) {       console.error("Import failed", error);       setImportState({         status: "error",         message: error instanceof Error ? error.message : "Не удалось обработать файл.",       });     }   };    const applyImport = (mode: "replace" | "merge") => {     if (importState.status !== "ready") return;     const prepared = prepareCatalogForExport(importState.preview.data);     if (mode === "replace") {       setCatalog(prepared);     } else {       setCatalog((prev) => mergeCatalogs(prev, prepared));     }     resetImportState();   };    const onImportInput = async (event: ChangeEvent<HTMLInputElement>) => {     const file = event.target.files?.[0];     if (!file) return;     await handleImportFile(file);   };    const resetImportState = () => {     setImportState({ status: "idle" });     if (fileInputRef.current) {       fileInputRef.current.value = "";     }   };   return (     <div className="mx-auto flex max-w-7xl flex-col gap-6 px-4 pb-24 pt-10 sm:px-6 lg:flex-row lg:px-8">       <aside className="lg:w-72">         <div className="space-y-3 rounded-2xl border border-slate-200 bg-white p-5 shadow-sm">           <h1 className="text-lg font-semibold text-slate-900">Настройка каталога</h1>           <p className="text-sm text-slate-600">             Менеджеры работают только с номенклатурой: категории и подкатегории выбираются из существующего справочника.             Новые разделы добавляются только через разработчиков.           </p>         </div>          <section className="mt-6 space-y-4 rounded-2xl border border-slate-200 bg-white p-5 shadow-sm">           <header className="flex flex-wrap items-center justify-between gap-3">             <div>               <h2 className="text-base font-semibold text-slate-900">Импорт из Excel</h2>               <p className="text-xs text-slate-500">                 Столбцы: «Категория», «Подкатегория», «Наименование», «Описание». Новые разделы не создаются.               </p>             </div>             <label className="inline-flex cursor-pointer items-center justify-center rounded-full border border-slate-300 px-4 py-2 text-xs font-semibold text-slate-900 transition hover:border-teal-500 hover:text-teal-600">               <input                 ref={fileInputRef}                 type="file"                 accept=".xlsx,.xls"                 className="hidden"                 onChange={onImportInput}               />               Выбрать файл             </label>           </header>           <p className="text-xs text-slate-500">             Скачайте {""}             <a               href="/templates/catalog-import.xlsx"               className="font-semibold text-teal-600 hover:text-teal-500"             >               шаблон для импорта             </a>{" "}             и заполните нужные строки.           </p>           {importState.status === "loading" && (             <p className="text-sm text-slate-500">Обрабатываем файл…</p>           )}           {importState.status === "error" && (             <div className="rounded-2xl border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-600">               {importState.message}               <button                 type="button"                 className="ml-2 text-xs font-semibold underline"                 onClick={resetImportState}               >                 Сбросить               </button>             </div>           )}           {importState.status === "ready" && (             <div className="space-y-3 text-xs text-slate-600">               <div className="flex flex-wrap items-center gap-2">                 <span className="rounded-full bg-slate-100 px-3 py-1 text-[11px] font-semibold uppercase tracking-[0.2em] text-slate-600">                   {importState.preview.filename}                 </span>                 <span className="rounded-full bg-teal-50 px-3 py-1 text-[11px] font-semibold text-teal-700">                   Категорий: {importState.preview.summary.categories}                 </span>                 <span className="rounded-full bg-teal-50 px-3 py-1 text-[11px] font-semibold text-teal-700">                   Подкатегорий: {importState.preview.summary.subcategories}                 </span>                 <span className="rounded-full bg-teal-50 px-3 py-1 text-[11px] font-semibold text-teal-700">                   Позиции: {importState.preview.summary.items}                 </span>               </div>               {importState.preview.errors.length > 0 && (                 <div className="rounded-2xl border border-red-200 bg-red-50 px-3 py-2 text-[11px] text-red-700">                   <div className="font-semibold text-red-800">Ошибки</div>                   <ul className="mt-1 space-y-1">                     {importState.preview.errors.slice(0, 5).map((error) => (                       <li key={error}>• {error}</li>                     ))}                   </ul>                 </div>               )}               {importState.preview.warnings.length > 0 && (                 <div className="rounded-2xl border border-yellow-200 bg-yellow-50 px-3 py-2 text-[11px] text-yellow-700">                   <div className="font-semibold text-yellow-800">Предупреждения</div>                   <ul className="mt-1 space-y-1">                     {importState.preview.warnings.slice(0, 5).map((warning) => (                       <li key={warning}>• {warning}</li>                     ))}                   </ul>                 </div>               )}               <div className="flex flex-wrap items-center gap-2">                 <button                   type="button"                   onClick={() => applyImport("replace")}                   className="inline-flex items-center justify-center rounded-full bg-teal-600 px-4 py-2 text-[11px] font-semibold uppercase tracking-[0.2em] text-white transition hover:bg-teal-500"                 >                   Заменить каталог                 </button>                 <button                   type="button"                   onClick={() => applyImport("merge")}                   className="inline-flex items-center justify-center rounded-full border border-teal-500 px-4 py-2 text-[11px] font-semibold uppercase tracking-[0.2em] text-teal-600 transition hover:bg-teal-50"                 >                   Объединить                 </button>                 <button                   type="button"                   onClick={resetImportState}                   className="inline-flex items-center justify-center rounded-full border border-slate-300 px-4 py-2 text-[11px] font-semibold text-slate-600 transition hover:border-slate-400 hover:text-slate-800"                 >                   Отмена                 </button>               </div>             </div>           )}         </section>          <section className="mt-6 space-y-4 rounded-2xl border border-slate-200 bg-white p-5 shadow-sm">           <header className="flex flex-wrap items-center justify-between gap-4">             <div>               <h2 className="text-base фонт-semibold text-slate-900">Экспорт JSON</h2>               <p className="text-xs text-slate-500">Используйте экспорт для резервного копирования и отправляйте каталог напрямую в `data/catalog.yml`.</p>             </div>             <div className="flex flex-wrap items-center gap-2">               <button                 type="button"                 onClick={handleCopyJson}                 className="rounded-full border border-slate-200 px-4 py-2 text-xs font-semibold text-teal-600 transition hover:border-teal-400 hover:text-teal-500"               >                 Скопировать JSON               </button>               <button                 type="button"                 onClick={saveCatalogToRepo}                 disabled={saveStatus === "saving"}                 className="rounded-full bg-teal-600 px-4 py-2 text-xs font-semibold text-white transition hover:bg-teal-500 disabled:cursor-not-allowed disabled:opacity-60"               >                 Сохранить в репозитории               </button>             </div>          </header>           {saveStatus !== "idle" && saveStatusMessage && (             <p className={`text-xs font-semibold ${saveStatusTone}`}>{saveStatusMessage}</p>           )}           <div className="relative">             <pre className="max-h-[320px] overflow-auto rounded-2xl border border-slate-200 bg-slate-900/95 p-4 text-xs text-slate-100">               {jsonForExport}             </pre>             {clipboardStatus === "success" && (               <span className="absolute right-4 top-4 rounded-full bg-emerald-500 px-3 py-1 text-[11px] font-semibold text-white shadow">                 Скопировано               </span>             )}             {clipboardStatus === "error" && (               <span className="absolute right-4 top-4 rounded-full bg-red-500 px-3 py-1 text-[11px] font-semibold text-white shadow">                 Не удалось               </span>             )}           </div>         </section>       </aside>       <main className="flex-1 space-y-6">         <section className="rounded-3xl border border-slate-200 bg-white p-6 shadow-sm">           <header className="flex flex-wrap items-center justify-between gap-4">             <div>               <h2 className="text-xl font-semibold text-slate-900">Номенклатура</h2>               <p className="text-sm text-slate-600">                 Изменяйте только позиции. Для каждой строки можно выбрать категорию и подкатегорию из справочника.               </p>             </div>             <button               type="button"               onClick={handleAddItem}               className="inline-flex items-center justify-center rounded-full bg-teal-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-teal-500"             >               Добавить позицию             </button>           </header>            <div className="mt-4 grid gap-3 md:grid-cols-2">             <label className="flex flex-col">               <span className="text-xs uppercase tracking-[0.3em] text-slate-500">Категория</span>               <select                 value={selectedCategoryFilter}                 onChange={(event) => {                   setSelectedCategoryFilter(event.target.value);                   setSelectedSubcategoryFilter("all");                 }}                 className="mt-1 w-full rounded-2xl border border-slate-200 px-3 py-2 text-sm outline-none transition focus:border-teal-500 focus:ring-2 focus:ring-teal-100"               >                 <option value="all">Все категории</option>                 {categoryOptions.map((option) => (                   <option key={option.value} value={option.value}>                     {option.label}                   </option>                 ))}               </select>             </label>             <label className="flex flex-col">               <span className="text-xs uppercase tracking-[0.3em] text-slate-500">Подкатегория</span>               <select                 value={selectedSubcategoryFilter}                 onChange={(event) => setSelectedSubcategoryFilter(event.target.value)}                 className="mt-1 w-full rounded-2xl border border-slate-200 px-3 py-2 text-sm outline-none transition focus:border-teal-500 focus:ring-2 focus:ring-teal-100"                 disabled={selectedCategoryFilter === "all"}               >                 <option value="all">Все подкатегории</option>                 {subcategoryOptions.map((option) => (                   <option key={option.value} value={option.value}>                     {option.label}                   </option>                 ))}               </select>             </label>           </div>            <div className="mt-6 overflow-x-auto">             <table className="min-w-full divide-y divide-slate-200 text-sm">               <thead>                 <tr className="bg-slate-50">                   <th className="whitespace-nowrap px-4 py-3 text-left font-semibold uppercase tracking-[0.2em] text-slate-500">Категория</th>                   <th className="whitespace-nowrap px-4 py-3 text-left font-semibold uppercase tracking-[0.2em] text-slate-500">Подкатегория</th>                   <th className="whitespace-nowrap px-4 py-3 text-left font-semibold uppercase tracking-[0.2em] text-slate-500">Наименование</th>                   <th className="whitespace-nowrap px-4 py-3 text-left font-semibold uppercase tracking-[0.2em] text-slate-500">Описание</th>                   <th className="whitespace-nowrap px-4 py-3 text-left font-semibold uppercase tracking-[0.2em] text-slate-500">Действия</th>                 </tr>               </thead>               <tbody className="divide-y divide-slate-200">                 {filteredRows.length === 0 && (                   <tr>                     <td colSpan={5} className="px-4 py-5 text-center text-sm text-slate-500">                       В выбранном разделе пока нет позиций.                     </td>                   </tr>                 )}                 {filteredRows.map((row) => {                   const availableSubcategories =                     catalog                       .find((category) => category.slug === row.categorySlug)                       ?.sub.map((subcategory) => ({                         value: subcategory.slug,                         label: subcategory.title,                       })) ?? [];                    return (                     <tr key={row.item.slug} className="bg-white">                       <td className="whitespace-nowrap px-4 py-3 align-top">                         <select                           value={row.categorySlug}                           onChange={(event) => {                             const nextCategorySlug = event.target.value;                             const nextCategory = catalog.find((category) => category.slug === nextCategorySlug);                             if (!nextCategory || nextCategory.sub.length === 0) return;                             const fallbackSubSlug =                               nextCategory.sub.find((sub) => sub.slug === row.subcategorySlug)?.slug ??                               nextCategory.sub[0].slug;                             moveItem(row.categorySlug, row.subcategorySlug, row.item.slug, nextCategorySlug, fallbackSubSlug);                           }}                           className="w-full rounded-xl border border-slate-200 px-3 py-2 text-sm outline-none transition focus:border-teal-500 focus:ring-2 focus:ring-teal-100"                         >                           {categoryOptions.map((option) => (                             <option key={option.value} value={option.value}>                               {option.label}                             </option>                           ))}                         </select>                       </td>                       <td className="whitespace-nowrap px-4 py-3 align-top">                         <select                           value={row.subcategorySlug}                           onChange={(event) =>                             moveItem(row.categorySlug, row.subcategorySlug, row.item.slug, row.categorySlug, event.target.value)                           }                           className="w-full rounded-xl border border-slate-200 px-3 py-2 text-sm outline-none transition focus:border-teal-500 focus:ring-2 focus:ring-teal-100"                         >                           {availableSubcategories.map((option) => (                             <option key={option.value} value={option.value}>                               {option.label}                             </option>                           ))}                         </select>                       </td>                       <td className="px-4 py-3 align-top">                         <input                           value={row.item.title}                           onChange={(event) =>                             updateItemInCatalog(row.categorySlug, row.subcategorySlug, row.item.slug, (item) => ({                               ...item,                               title: event.target.value,                               slug: slugify(event.target.value),                               sku: generateSku(event.target.value),                             }))                           }                           placeholder="Название позиции"                           className="w-full rounded-xl border border-slate-200 px-3 py-2 text-sm outline-none transition focus:border-teal-500 focus:ring-2 focus:ring-teal-100"                         />                       </td>                       <td className="px-4 py-3 align-top">                         <input                           value={row.item.desc ?? ""}                           onChange={(event) =>                             updateItemInCatalog(row.categorySlug, row.subcategorySlug, row.item.slug, (item) => ({                               ...item,                               desc: event.target.value,                             }))                           }                           placeholder="Короткое описание (необязательно)"                           className="w-full rounded-xl border border-slate-200 px-3 py-2 text-sm outline-none transition focus:border-teal-500 focus:ring-2 focus:ring-teal-100"                         />                       </td>                       <td className="whitespace-nowrap px-4 py-3 align-top">                         <button                           type="button"                           onClick={() =>                             removeItemFromCatalog(row.categorySlug, row.subcategorySlug, row.item.slug)                           }                           className="rounded-full border border-red-200 px-3 py-1 text-xs font-semibold text-red-600 transition hover:border-red-400 hover:bg-red-50"                         >                           Удалить                         </button>                       </td>                     </tr>                   );                 })}               </tbody>             </table>           </div>         </section>       </main>     </div>   ); }